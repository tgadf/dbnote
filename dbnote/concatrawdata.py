""" Store Data Class """__all__ = ["ConcatRawData"]from dbbase import getModVals, MusicDBIDModValfrom dbparse import RawDataDirIOfrom musicdb import getdbiofrom utils import FileInfo, getFile, FileIO, headerfrom time import sleepclass ConcatRawData:    def __repr__(self):        return f"ConcatRawData(db={self.dbio.db}, dtype={self.dtype}"            def __init__(self, db, dType):        self.mv = MusicDBIDModVal()        self.dbio = getdbio(db, local=True)        self.dtype = dType        self.dbdir = self.dbio.rdio.getDBDir(f"Raw{self.dtype}ModVal")        self.rddio = RawDataDirIO(self.dbio.rdio)        self.tmpDir = self.dbio.rdio.getDir("Raw").join("tmp")        self.tmpDir.mkDir()                print(self.__repr__())    ###########################################################################    # Concat Local Data    ###########################################################################    def sortFiles(self, modVal=None) -> 'dict':        def getIDs(finfo: FileInfo) -> 'tuple':            fdbid = finfo.basename            fModVal = self.mv.getModVal(fdbid)            fGlobVal = self.mv.getGlobVal(fdbid)            return fdbid, fModVal, fGlobVal        globData = {}        modVals = [modVal] if isinstance(modVal, int) else getModVals()        for modVal in modVals:            modGlobVal = self.mv.getModGlobVal(modVal)            globData[modGlobVal] = {}            modValDir = self.dbdir.get(modVal)            files = modValDir.getFiles()            print(modValDir,'\t',len(files))            for ifile in files:                finfo = FileInfo(ifile)                fdbid, fModVal, fGlobVal = getIDs(finfo)                assert fModVal == modVal, f"Mismatched ModVal: [{fModVal}] vs [{modVal}] ({finfo})"                fModGlobVal = self.mv.getModGlobVal(fGlobVal)                if globData[modGlobVal].get(fModGlobVal) is None:                    globData[modGlobVal][fModGlobVal] = {}                globData[modGlobVal][fModGlobVal][fdbid] = finfo        return globData    def getRawData(self, finfo):        try:            localData = getFile(finfo)        except Exception as error:            print(f"Error with {finfo.str}: {error}")            localData = None        return localData        def concat(self, modVal=None):        header(f"Concat {self.dbio.db} {self.dtype} Data", width=125)        modVals = [modVal] if isinstance(modVal, int) else getModVals()        for modVal in modVals:            self.concatModVal(modVal)                    def concatModVal(self, modVal):        assert isinstance(modVal, int), f"Invalid ModVal [{modVal}]"        sortedFiles = self.sortFiles(modVal)        io = FileIO()        for fModVal, fModValData in sorted(sortedFiles.items()):            nFiles = sum([len(x) for x in fModValData.values()])            for fGlobVal, fGlobValData in sorted(fModValData.items()):                globData = {fdbid: self.getRawData(finfo) for fdbid, finfo in sorted(fGlobValData.items())}                globFile = self.tmpDir.join(self.rddio.getFilename(self.dtype, int(fModVal), int(fGlobVal)))                io.save(idata=globData, ifile=globFile)            if (int(fModVal) + 1) % 25 == 0:                print("")    ###########################################################################    # Merge Local And Perm Data    ###########################################################################    def merge(self, modVal=None, test=True):        header(f"Merging {self.dbio.db} {self.dtype} Data", width=125)        modVals = [modVal] if isinstance(modVal, int) else getModVals()        for modVal in modVals:            self.mergeModVal(modVal=modVal, test=test)                def mergeModVal(self, modVal, test=True):        assert isinstance(modVal, int), f"Invalid ModVal [{modVal}]"        dbioPerm = getdbio(self.dbio.db, mkDirs=True)        dbdir = dbioPerm.rdio.getDBDir(f"Raw{self.dtype}ModVal")        io = FileIO()        fModVal = modVal        dstDir = dbdir.get(fModVal)        for fGlobVal in getModVals():            fname = self.rddio.getFilename(self.dtype, fModVal, fGlobVal)            srcFile = self.tmpDir.join(fname)            if not srcFile.exists():                continue            dstFile = dstDir.join(fname)            if dstFile.exists():                if test is True:                    print(f"Will merge [{srcFile}] and [{dstFile}] and save to [{dstFile}]")                    break                prevData = io.get(dstFile)                newData = io.get(srcFile)                globData = newData | prevData                io.save(idata=globData, ifile=dstFile)                sleep(0.1)            else:                if test is True:                    print(f"Will move [{srcFile}] to [{dstFile}]")                    break                srcFile.mvFile(dstFile, debug=False)                sleep(0.1)                        if (int(fModVal) + 1) % 25 == 0:            print("")    ###########################################################################    # Merge Local Data    ###########################################################################    def remove(self, modVal=None, force=False):        header(f"Removing {self.dbio.db} {self.dtype} Data", width=125)        modVals = [modVal] if isinstance(modVal, int) else getModVals()        for modVal in modVals:            self.removeModVal(modVal=modVal, force=force)    def removeModVal(self, modVal, force=False):        if force is True:            if self.tmpDir.exists():                self.tmpDir.rmDir()                            for ifile in self.dbdir.get(modVal).getFiles():                FileInfo(ifile).rmFile(debug=False)        else:            print("Will remove tmpDir and files if force is True")