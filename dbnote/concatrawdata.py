""" Store Data Class """__all__ = ["ConcatRawData"]from dbbase import getModVals, MusicDBIDModValfrom dbparse import RawDataDirIOfrom musicdb import getdbiofrom utils import FileInfo, getFile, FileIO, headerfrom time import sleepclass ConcatRawData:    def __repr__(self):        return f"ConcatRawData(db={self.dbio.db}, dtype={self.dtype}"            def __init__(self, db, dType):        self.mv = MusicDBIDModVal()        self.dbio = getdbio(db, local=True)        self.dtype = dType        self.dbdir = self.dbio.rdio.getDBDir(f"Raw{self.dtype}ModVal")        self.rddio = RawDataDirIO(self.dbio.rdio)        self.tmpDir = self.dbio.rdio.getDir("Raw").join("tmp")                print(self.__repr__())    ###########################################################################    # Concat Local Data    ###########################################################################    def sortFiles(self) -> 'dict':        def getIDs(finfo: FileInfo) -> 'tuple':            fdbid = finfo.basename            fModVal = self.mv.getModVal(fdbid)            fGlobVal = self.mv.getGlobVal(fdbid)            return fdbid, fModVal, fGlobVal        globData = {}        for modVal in getModVals():            modGlobVal = self.mv.getModGlobVal(modVal)            globData[modGlobVal] = {}            modValDir = self.dbdir.get(modVal)            for ifile in modValDir.getFiles():                finfo = FileInfo(ifile)                fdbid, fModVal, fGlobVal = getIDs(finfo)                assert fModVal == modVal, f"Mismatched ModVal: [{fModVal}] vs [{modVal}] ({finfo})"                fModGlobVal = self.mv.getModGlobVal(fGlobVal)                if globData[modGlobVal].get(fModGlobVal) is None:                    globData[modGlobVal][fModGlobVal] = {}                globData[modGlobVal][fModGlobVal][fdbid] = finfo        return globData                def concat(self):        def getRawData(finfo):            try:                localData = getFile(finfo)            except Exception as error:                print(f"Error with {finfo.str}: {error}")                localData = None            return localData        header(f"Concat {self.dbio.db} {self.dtype} Data", width=125)        self.tmpDir.mkDir()        io = FileIO()        sortedFiles = self.sortFiles()        for fModVal, fModValData in sorted(sortedFiles.items()):            print(".", end="")            for fGlobVal, fGlobValData in sorted(fModValData.items()):                globData = {fdbid: getRawData(finfo) for fdbid, finfo in sorted(fGlobValData.items())}                globFile = self.tmpDir.join(self.rddio.getFilename(self.dtype, int(fModVal), int(fGlobVal)))                io.save(idata=globData, ifile=globFile)            if (int(fModVal) + 1) % 25 == 0:                print("")    ###########################################################################    # Merge Local And Perm Data    ###########################################################################    def merge(self, test=True):        dbioPerm = getdbio(self.dbio.db, mkDirs=True)        dbdir = dbioPerm.rdio.getDBDir(f"Raw{self.dtype}ModVal")        io = FileIO()        header(f"Merging {self.dbio.db} {self.dtype} Data", width=125)        for fModVal in getModVals():            print(".", end="")            dstDir = dbdir.get(fModVal)            for fGlobVal in getModVals():                fname = self.rddio.getFilename(self.dtype, fModVal, fGlobVal)                srcFile = self.tmpDir.join(fname)                if not srcFile.exists():                    continue                dstFile = dstDir.join(fname)                if dstFile.exists():                    if test is True:                        print(f"Will merge [{srcFile}] and [{dstFile}] and save to [{dstFile}]")                        break                    prevData = io.get(dstFile)                    newData = io.get(srcFile)                    globData = newData | prevData                    io.save(idata=globData, ifile=dstFile)                    sleep(0.1)                else:                    if test is True:                        print(f"Will move [{srcFile}] to [{dstFile}]")                        break                    srcFile.mvFile(dstFile, debug=False)                    sleep(0.1)                                if (int(fModVal) + 1) % 25 == 0:                print("")    ###########################################################################    # Merge Local Data    ###########################################################################    def remove(self, force=False):        header(f"Removing {self.dbio.db} {self.dtype} Data", width=125)        if force is True:            if self.tmpDir.exists():                self.tmpDir.rmDir()            for modVal in getModVals():                print(".", end="")                for ifile in self.dbdir.get(modVal).getFiles():                    FileInfo(ifile).rmFile(debug=False)                if (int(modVal) + 1) % 25 == 0:                    print("")        else:            print("Will remove tmpDir and files if force is True")